<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Local Audio → WAV Converter | TTSReader</title>

    <style>
        body {
            font-family: system-ui, sans-serif;
            background: #f5f5f5;
            padding: 24px;
            max-width: 700px;
            margin: auto;
        }

        h1 {
            margin-bottom: 0.5em;
        }

        .box {
            background: #fff;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        label {
            display: block;
            margin: 8px 0 4px;
            font-weight: 600;
        }

        select, input[type="file"], button {
            width: 100%;
            padding: 8px;
            font-size: 14px;
        }

        button {
            margin-top: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress {
            margin-top: 12px;
            height: 16px;
            background: #ddd;
            border-radius: 8px;
            overflow: hidden;
        }

        .progress > div {
            height: 100%;
            width: 0%;
            background: #4caf50;
            transition: width 0.1s linear;
        }

        .hint {
            font-size: 12px;
            color: #555;
            margin-top: 4px;
        }
    </style>
</head>

<body>

<h1>Local Audio / Video (MP3, MP4, etc.) to WAV Converter</h1>
<h2 style="color: #666666; font-weight: normal">A service to TTSReader's users.</h2>
<h3 style="color: #666666;">Super private & safe. Processed 100% on your device, not sent anywhere.</h3>

<div class="box">
    <label>Select audio file</label>
    <input type="file" id="fileInput" accept="audio/*">
    <div class="hint">MP3, WAV, OGG, etc. (local file only)</div>
</div>

<div class="box">
    <label>Sample rate (Hz)</label>
    <select id="sampleRate" disabled>
        <option value="44100" selected>44100 (CD / default)</option>
        <option value="22050">22050 (embedded / low power)</option>
        <option value="16000">16000 (speech / ML)</option>
        <option value="8000">8000 (telephony)</option>
    </select>

    <label>Bit depth</label>
    <select id="bitDepth" disabled>
        <option value="16" selected>16-bit PCM (default)</option>
        <option value="8">8-bit PCM</option>
    </select>

    <label>Channels</label>
    <select id="channels" disabled>
        <option value="source" selected>Same as source</option>
        <option value="mono">Mono (average channels)</option>
        <option value="stereo">Stereo</option>
    </select>
</div>

<div class="box">
    <div class="hint" id="outputSize">
        Expected output size: —
    </div>

    <button id="exportBtn" disabled>Export & download WAV file</button>

    <div class="progress">
        <div id="progressBar"></div>
    </div>
</div>

<script>
    const MAX_DECODED_MB = 400;
    const HARD_FILE_LIMIT_MB = 1000;

    const fileInput = document.getElementById("fileInput");
    const sampleRateSel = document.getElementById("sampleRate");
    const bitDepthSel = document.getElementById("bitDepth");
    const channelsSel = document.getElementById("channels");
    const exportBtn = document.getElementById("exportBtn");
    const progressBar = document.getElementById("progressBar");

    let audioBuffer = null;
    let sourceChannels = 0;

    async function estimateDecodedSize(file) {
        return new Promise((resolve, reject) => {
            const audio = document.createElement("audio");
            audio.preload = "metadata";

            audio.onloadedmetadata = () => {
                const duration = audio.duration;
                const sampleRate = 44100; // worst-case assumption
                const channels = audio.mozChannels || audio.webkitAudioDecodedByteCount
                    ? 2
                    : 2; // assume stereo if unknown

                const decodedBytes =
                    duration * sampleRate * channels * 4;

                resolve({
                    duration,
                    channels,
                    decodedBytes,
                    decodedMB: decodedBytes / (1024 * 1024)
                });

                URL.revokeObjectURL(audio.src);
            };

            audio.onerror = () => {
                reject(new Error("Unable to read audio metadata"));
            };

            audio.src = URL.createObjectURL(file);
        });
    }

    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if (!file) return;

        // Optional early file-size guard
        if (file.size > HARD_FILE_LIMIT_MB * 1024 * 1024) {
            alert(
                `File is ${Math.round(file.size / 1024 / 1024)} MB.\n` +
                `This is too large for safe in-browser processing.\n\n` +
                `Please use a smaller file or or download audacity (open source audio app - https://www.audacityteam.org/download/ ) to use as a converter.`
            );
            fileInput.value = "";
            return;
        }

        let estimate;
        try {
            estimate = await estimateDecodedSize(file);
        } catch (e) {
            alert("Could not read audio metadata.");
            return;
        }

        if (estimate.decodedMB > MAX_DECODED_MB) {
            alert(
                `This file would decode to ~${estimate.decodedMB.toFixed(0)} MB of audio.\n\n` +
                `Browsers cannot safely handle this much audio in memory.\n\n` +
                `Please use a shorter file or download audacity (open source audio app - https://www.audacityteam.org/download/ ) to use as a converter.`
            );
            fileInput.value = "";
            return;
        }

        // SAFE to decode
        const arrayBuffer = await file.arrayBuffer();
        const ctx = new AudioContext();
        audioBuffer = await ctx.decodeAudioData(arrayBuffer);

        sourceChannels = audioBuffer.numberOfChannels;

        // Enable UI (your existing logic)
        sampleRateSel.disabled = false;
        bitDepthSel.disabled = false;
        channelsSel.disabled = false;
        exportBtn.disabled = false;

        updateExpectedSize();
    };

    exportBtn.onclick = async () => {
        progressBar.style.width = "0%";

        const sampleRate = parseInt(sampleRateSel.value, 10);
        const bitDepth = parseInt(bitDepthSel.value, 10);
        const channelChoice = channelsSel.value;

        const targetChannels =
            channelChoice === "mono" ? 1 :
                channelChoice === "stereo" ? 2 :
                    sourceChannels;

        const length = Math.ceil(audioBuffer.duration * sampleRate);
        const offline = new OfflineAudioContext(
            targetChannels,
            length,
            sampleRate
        );

        const src = offline.createBufferSource();

        let bufferToRender = audioBuffer;

        // Stereo → mono averaging
        if (audioBuffer.numberOfChannels === 2 && targetChannels === 1) {
            const mono = offline.createBuffer(1, audioBuffer.length, audioBuffer.sampleRate);
            const ch0 = audioBuffer.getChannelData(0);
            const ch1 = audioBuffer.getChannelData(1);
            const out = mono.getChannelData(0);
            for (let i = 0; i < out.length; i++) {
                out[i] = (ch0[i] + ch1[i]) * 0.5;
            }
            bufferToRender = mono;
        }

        src.buffer = bufferToRender;
        src.connect(offline.destination);
        src.start();

        // Fake but smooth progress
        let p = 0;
        const progressTimer = setInterval(() => {
            p = Math.min(p + 2, 90);
            progressBar.style.width = p + "%";
        }, 100);

        const rendered = await offline.startRendering();
        clearInterval(progressTimer);
        progressBar.style.width = "100%";

        const wavBlob = audioBufferToWav(rendered, bitDepth);
        const url = URL.createObjectURL(wavBlob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "export.wav";
        a.click();

        URL.revokeObjectURL(url);
    };

    function audioBufferToWav(buffer, bitDepth) {
        const numChannels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        const samples = buffer.length;
        const bytesPerSample = bitDepth / 8;
        const blockAlign = numChannels * bytesPerSample;
        const bufferSize = 44 + samples * blockAlign;
        const arrayBuffer = new ArrayBuffer(bufferSize);
        const view = new DataView(arrayBuffer);

        let offset = 0;
        const writeString = s => { for (let i = 0; i < s.length; i++) view.setUint8(offset++, s.charCodeAt(i)); };

        writeString("RIFF");
        view.setUint32(offset, bufferSize - 8, true); offset += 4;
        writeString("WAVE");
        writeString("fmt ");
        view.setUint32(offset, 16, true); offset += 4;
        view.setUint16(offset, 1, true); offset += 2;
        view.setUint16(offset, numChannels, true); offset += 2;
        view.setUint32(offset, sampleRate, true); offset += 4;
        view.setUint32(offset, sampleRate * blockAlign, true); offset += 4;
        view.setUint16(offset, blockAlign, true); offset += 2;
        view.setUint16(offset, bitDepth, true); offset += 2;
        writeString("data");
        view.setUint32(offset, samples * blockAlign, true); offset += 4;

        for (let i = 0; i < samples; i++) {
            for (let ch = 0; ch < numChannels; ch++) {
                let sample = buffer.getChannelData(ch)[i];
                sample = Math.max(-1, Math.min(1, sample));
                if (bitDepth === 16) {
                    view.setInt16(offset, sample * 0x7fff, true);
                } else {
                    view.setUint8(offset, (sample + 1) * 127.5);
                }
                offset += bytesPerSample;
            }
        }

        return new Blob([arrayBuffer], { type: "audio/wav" });
    }

    function updateExpectedSize() {
        if (!audioBuffer) return;

        const sampleRate = parseInt(sampleRateSel.value, 10);
        const bitDepth = parseInt(bitDepthSel.value, 10);

        let channels;
        const mode = channelsSel.value;

        if (mode === "mono") channels = 1;
        else if (mode === "stereo") channels = 2;
        else channels = sourceChannels;

        const duration = audioBuffer.duration;
        const bytesPerSample = bitDepth / 8;

        const dataSize =
            duration * sampleRate * channels * bytesPerSample;

        const totalSize = Math.round(44 + dataSize);

        document.getElementById("outputSize").textContent =
            `Expected output size: ${formatBytes(totalSize)}`;
    }

    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 ** 2) return (bytes / 1024).toFixed(1) + " KB";
        return (bytes / 1024 ** 2).toFixed(2) + " MB";
    }

    sampleRateSel.onchange = updateExpectedSize;
    bitDepthSel.onchange = updateExpectedSize;
    channelsSel.onchange = updateExpectedSize;
</script>

</body>
</html>